"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors = __importStar(require("../errors.js"));
const fs = __importStar(require("fs"));
const transform_js_js_1 = require("./transform/transform-js.js");
const transform_ts_js_1 = require("./transform/transform-ts.js");
class JavaScriptProcessor {
    constructor() {
        this.babelOptions = {
            "\\S+.ts$": {
                "presets": [
                    ["@babel/preset-env", {
                            "targets": { chrome: 58 }
                        }],
                ],
                plugins: [
                    "@babel/plugin-transform-typescript",
                ]
            },
            "\\S+.js$": {
                "presets": [
                    ["@babel/preset-env", {
                            "targets": { chrome: 58 }
                        }],
                ],
                plugins: [
                // "@babel/plugin-transform-modules-amd"
                ]
            },
            "\\S+.tsx$": {
                "presets": [
                    ["@babel/preset-env", {
                            "targets": { chrome: 58 }
                        }],
                ],
                plugins: [
                    ["@babel/plugin-transform-typescript", { isTSX: true }],
                    ["@babel/plugin-transform-react-jsx", { "pragma": "React.createElement", "pragmaFrag": "React.Fragment" }],
                    "@babel/plugin-transform-modules-amd"
                ]
            },
            "\\S+.jsx$": {
                "presets": [
                    ["@babel/preset-env", {
                            "targets": { chrome: 58 }
                        }],
                ],
                plugins: [
                    ["@babel/plugin-transform-react-jsx", { "pragma": "React.createElement", "pragmaFrag": "React.Fragment" }],
                ]
            },
        };
        this.ignorePaths = ["\\S+node_modules\\S+", "\\S+lib\\S+"];
    }
    async execute(ctx) {
        if (!ctx.virtualPath.endsWith(".js") && !ctx.virtualPath.endsWith(".ts") &&
            !ctx.virtualPath.endsWith(".jsx") && !ctx.virtualPath.endsWith(".tsx"))
            return null;
        let jsVirtualPath = ctx.virtualPath;
        let jsxVirtualPath = ctx.virtualPath.substr(0, ctx.virtualPath.length - ".js".length) + ".jsx";
        let tsVirtualPath = ctx.virtualPath.substr(0, ctx.virtualPath.length - ".js".length) + ".ts";
        let tsxVirtualPath = ctx.virtualPath.substr(0, ctx.virtualPath.length - ".js".length) + ".tsx";
        let physicalPath = ctx.rootDirectory.findFile(jsVirtualPath);
        if (physicalPath == null) {
            physicalPath = ctx.rootDirectory.findFile(jsxVirtualPath);
        }
        if (physicalPath == null) {
            physicalPath = ctx.rootDirectory.findFile(tsVirtualPath);
        }
        if (physicalPath == null) {
            physicalPath = ctx.rootDirectory.findFile(tsxVirtualPath);
        }
        if (physicalPath == null) {
            throw errors.pageNotFound(`${jsxVirtualPath} ${jsVirtualPath} ${tsVirtualPath} ${tsxVirtualPath}`);
        }
        let buffer = fs.readFileSync(physicalPath);
        let code = buffer.toString();
        let options;
        let skip = false;
        for (let i = 0; i < this.ignorePaths.length; i++) {
            let regex = new RegExp(this.ignorePaths[i]);
            if (regex.test(ctx.virtualPath)) {
                skip = true;
                break;
            }
        }
        if (!skip) {
            for (let key in this.babelOptions) {
                let regex = new RegExp(key);
                if (regex.test(physicalPath)) {
                    options = this.babelOptions[key];
                    break;
                }
            }
        }
        if (options) {
            let isTS = physicalPath.endsWith(".ts") || physicalPath.endsWith(".tsx");
            if (isTS) {
                // let r = babel.transform(code, options);
                // code = r?.code || "/** Babel transform code fail. */";
                code = transform_ts_js_1.transformTS(code, options);
            }
            else {
                code = transform_js_js_1.transformJS(code, options);
            }
        }
        const encoding = 'UTF-8';
        return { content: code, headers: { "content-type": `application/x-javascript; charset=${encoding}` } };
    }
}
exports.JavaScriptProcessor = JavaScriptProcessor;
