"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors = __importStar(require("../../errors"));
class NodeConverter {
    transform(node) {
        if (node == null)
            throw errors.argumentNull("node");
        switch (node.type) {
            case "Program":
                for (let i = 0; i < node.body.length; i++) {
                    node.body[i] = this.transform(node.body[i]);
                }
                break;
            case "ImportDeclaration":
                node.source = this.transform(node.source);
                break;
            case "File":
                node.program = this.transform(node.program);
                break;
            case "VariableDeclaration":
                for (let i = 0; i < node.declarations.length; i++) {
                    node.declarations[i] = this.transform(node.declarations[i]);
                }
                break;
            case "VariableDeclarator":
                if (node.init != null)
                    node.init = this.transform(node.init);
                break;
            case "CallExpression":
                node.callee = this.transform(node.callee);
                for (let i = 0; i < node.arguments.length; i++) {
                    node.arguments[i] = this.transform(node.arguments[i]);
                }
                break;
            case "ExpressionStatement":
                node.expression = this.transform(node.expression);
                break;
        }
        return node;
    }
}
exports.NodeConverter = NodeConverter;
