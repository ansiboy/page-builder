"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const maishu_toolkit_1 = require("maishu-toolkit");
const node_converter_1 = require("./node-converter");
const babel = require("@babel/core");
const path = __importStar(require("path"));
function transformTS(originalCode, options) {
    let ast = babel.parseSync(originalCode, options);
    new TSNodeConerter().transform(ast);
    let r = babel.transformFromAstSync(ast, undefined, options);
    let code = r?.code || "/** Babel transform code fail. */";
    return code;
}
exports.transformTS = transformTS;
class TSNodeConerter extends node_converter_1.NodeConverter {
    transform(node) {
        if (node == null)
            throw maishu_toolkit_1.errors.argumentNull("node");
        switch (node.type) {
            case "ImportDeclaration":
                if (node.source != null && node.source.type == "StringLiteral") {
                    let moduleName = node.source.value;
                    if ((moduleName.endsWith(".scss") || moduleName.endsWith(".css") || moduleName.endsWith(".less")) && !moduleName.startsWith("css!")) {
                        let ext = path.extname(moduleName);
                        moduleName = "css!" + moduleName.substr(0, moduleName.length - ext.length) + ".css";
                        node.source.value = moduleName;
                    }
                }
                break;
        }
        return super.transform(node);
    }
}
