"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const maishu_node_web_server_1 = require("maishu-node-web-server");
const fs = require("fs");
const transform_js_js_1 = require("./transform/transform-js.js");
const transform_ts_js_1 = require("./transform/transform-ts.js");
const path = require("path");
class JavaScriptProcessor {
    constructor() {
        this.options = {
            babel: {
                "\\S+.ts$": {
                    "presets": [
                        ["@babel/preset-env", {
                                "targets": { chrome: 58 }
                            }],
                    ],
                    plugins: [
                        "@babel/plugin-transform-typescript",
                    ]
                },
                "\\S+.js$": {
                    "presets": [
                        ["@babel/preset-env", {
                                "targets": { chrome: 58 }
                            }],
                    ],
                    plugins: []
                },
                "\\S+.tsx$": {
                    "presets": [
                        ["@babel/preset-env", {
                                "targets": { chrome: 58 }
                            }],
                    ],
                    plugins: [
                        ["@babel/plugin-transform-typescript", { isTSX: true }],
                        ["@babel/plugin-transform-react-jsx", { "pragma": "React.createElement", "pragmaFrag": "React.Fragment" }],
                    ]
                },
                "\\S+.jsx$": {
                    "presets": [
                        ["@babel/preset-env", {
                                "targets": { chrome: 58 }
                            }],
                    ],
                    plugins: [
                        ["@babel/plugin-transform-react-jsx", { "pragma": "React.createElement", "pragmaFrag": "React.Fragment" }],
                    ]
                },
            },
            ignorePaths: ["\\S+node_modules\\S+", "\\S+lib\\S+"],
        };
    }
    get babelOptions() {
        return this.options.babel;
    }
    set babelOptions(value) {
        this.options.babel = value;
    }
    get ignorePaths() {
        return this.options.ignorePaths;
    }
    set ignorePaths(value) {
        this.options.ignorePaths = value;
    }
    get basePath() {
        return this.options.directoryPath;
    }
    ;
    set basePath(value) {
        this.options.directoryPath = value;
    }
    execute(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!ctx.virtualPath.endsWith(".js") && !ctx.virtualPath.endsWith(".ts") &&
                !ctx.virtualPath.endsWith(".jsx") && !ctx.virtualPath.endsWith(".tsx"))
                return null;
            let pathWidthoutExt = ctx.virtualPath;
            if (pathWidthoutExt.endsWith(".js")) {
                pathWidthoutExt = pathWidthoutExt.substring(0, pathWidthoutExt.length - ".js".length);
            }
            if (pathWidthoutExt.endsWith(".ts") || pathWidthoutExt.endsWith(".tsx")) {
                let ext = path.extname(pathWidthoutExt);
                pathWidthoutExt = pathWidthoutExt.substr(0, pathWidthoutExt.length - ext.length);
            }
            let jsVirtualPath = pathWidthoutExt + ".js";
            let jsxVirtualPath = pathWidthoutExt + ".jsx";
            let tsVirtualPath = pathWidthoutExt + ".ts";
            let tsxVirtualPath = pathWidthoutExt + ".tsx";
            let dir = this.basePath ? ctx.rootDirectory.findDirectory(this.basePath) : ctx.rootDirectory;
            if (!dir)
                return null;
            let physicalPath = dir.findFile(jsVirtualPath);
            if (physicalPath == null) {
                physicalPath = dir.findFile(jsxVirtualPath);
            }
            if (physicalPath == null) {
                physicalPath = dir.findFile(tsVirtualPath);
            }
            if (physicalPath == null) {
                physicalPath = dir.findFile(tsxVirtualPath);
            }
            if (physicalPath == null) {
                return null;
                // throw errors.pageNotFound(`${jsxVirtualPath} ${pathWidthoutExt} ${tsVirtualPath} ${tsxVirtualPath}`, dir.virtualPath);
            }
            let isTS = physicalPath.endsWith(".ts") || physicalPath.endsWith(".tsx");
            let isJS = !isTS;
            let skip = false;
            if (isJS) {
                for (let i = 0; i < this.ignorePaths.length; i++) {
                    let regex = new RegExp(this.ignorePaths[i]);
                    if (regex.test(ctx.virtualPath)) {
                        skip = true;
                        break;
                    }
                }
            }
            if (skip)
                return null;
            let pkg = require("../package.json");
            let logger = maishu_node_web_server_1.getLogger(pkg.name, ctx.logLevel);
            logger.info(`Physical path is ${physicalPath}.`);
            let buffer = fs.readFileSync(physicalPath);
            let code = buffer.toString();
            let options;
            for (let key in this.babelOptions) {
                let regex = new RegExp(key);
                if (regex.test(physicalPath)) {
                    options = this.babelOptions[key];
                    logger.info(`Babel option key is ${key}.`);
                    break;
                }
            }
            if (options) {
                logger.info(`Babel option is:\n`);
                logger.info(options);
                if (isTS) {
                    // let r = babel.transform(code, options);
                    // code = r?.code || "/** Babel transform code fail. */";
                    code = transform_ts_js_1.transformTS(code, options);
                }
                else {
                    code = transform_js_js_1.transformJS(code, options);
                }
            }
            const encoding = 'UTF-8';
            return { content: code, headers: { "content-type": `application/x-javascript; charset=${encoding}` } };
        });
    }
    static transformJS(originalCode, options) {
        return transform_js_js_1.transformJS(originalCode, options);
    }
    static transformTS(originalCode, options) {
        return transform_ts_js_1.transformTS(originalCode, options);
    }
}
exports.JavaScriptProcessor = JavaScriptProcessor;
