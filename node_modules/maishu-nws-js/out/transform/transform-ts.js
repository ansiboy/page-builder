"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const maishu_toolkit_1 = require("maishu-toolkit");
const node_converter_1 = require("./node-converter");
const babel = require("@babel/core");
const path = require("path");
function transformTS(originalCode, options) {
    let ast = babel.parseSync(originalCode, options);
    new TSNodeConerter().transform(ast);
    let r = babel.transformFromAstSync(ast, undefined, options);
    let code = (r === null || r === void 0 ? void 0 : r.code) || "/** Babel transform code fail. */";
    return code;
}
exports.transformTS = transformTS;
class TSNodeConerter extends node_converter_1.NodeConverter {
    transform(node) {
        if (node == null)
            throw maishu_toolkit_1.errors.argumentNull("node");
        switch (node.type) {
            case "ImportDeclaration":
                if (node.source != null && node.source.type == "StringLiteral") {
                    let moduleName = node.source.value;
                    if ((moduleName.endsWith(".scss") || moduleName.endsWith(".css") || moduleName.endsWith(".less")) && !moduleName.startsWith("css!")) {
                        let ext = path.extname(moduleName);
                        moduleName = "css!" + moduleName.substr(0, moduleName.length - ext.length) + ".css";
                        node.source.value = moduleName;
                    }
                }
                break;
        }
        return super.transform(node);
    }
}
